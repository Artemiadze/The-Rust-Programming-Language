use std::sync::{Arc, Mutex}; // импортируем Arc (умный указатель для многопоточного доступа) и Mutex (мьютекс для защиты данных)
use std::thread;

pub fn shared() {
    // Создаём "счётчик", обёрнутый в Arc<Mutex<i32>>:
    // - Mutex гарантирует, что только один поток может изменять значение одновременно
    // - Arc (Atomic Reference Counter) позволяет безопасно делиться этим Mutex между потоками
    let counter = Arc::new(Mutex::new(0));

    // Вектор для хранения "дескрипторов" (handle) потоков
    let mut handles = vec![];

    // Запускаем 10 потоков
    for _ in 0..10 {
        // Клонируем Arc, чтобы передать "счётчик" в новый поток
        // (Arc увеличивает счётчик ссылок атомарно, так что все потоки делят одно и то же значение)
        let counter = Arc::clone(&counter);

        // Создаём новый поток
        let handle = thread::spawn(move || {
            // Блокируем мьютекс, чтобы получить доступ к разделяемому числу
            // `lock()` возвращает Result<MutexGuard, PoisonError>, поэтому используем unwrap()
            let mut num = counter.lock().unwrap();

            // Изменяем значение внутри мьютекса
            *num += 1; // увеличиваем счётчик на 1
        });

        // Сохраняем "дескриптор" потока, чтобы потом дождаться его завершения
        handles.push(handle);
    }

    // Дожидаемся завершения всех потоков
    for handle in handles {
        handle.join().unwrap();
    }

    // После завершения всех потоков снова блокируем мьютекс и печатаем результат
    println!("Result: {}", *counter.lock().unwrap());
}
